//
//  Entities.swift
//  Asteroids
//
//  Created by Sean Hickey on 12/6/16.
//  Copyright Â© 2016 Sean Hickey. All rights reserved.
//

import Darwin
import simd

typealias Transform = float4x4

/****************************************
 * Renderable Struct for Vertex Data
 ****************************************/

typealias RenderableId = U64

/*= BEGIN_REFSTRUCT =*/
struct Renderable {
    var vertexCount : Int /*= GETSET =*/
    var vertexBuffer : RawPtr /*= GETSET =*/
    
    var boundingBox : Rect /*= GETSET =*/
    var boundingBoxBuffer : RawPtr /*= GETSET =*/
}
/*= END_REFSTRUCT =*/


func createRenderable(_ zone: MemoryZoneRef, _ gameState: GameStateRef, _ gameMemory: GameMemory, _ vertices: [Float]) -> RenderableRef {
    
    // TODO : This function assumes a vertex buffer layout of [x, y, z, w, r, g, b, a]
    assert(vertices.count % 8 == 0)
    
    let renderablePtr = allocateTypeFromZone(zone, Renderable.self)
    var renderable = RenderableRef(ptr: renderablePtr)
    
    renderable.vertexBuffer = gameMemory.platformCreateVertexBuffer!(vertices)
    renderable.vertexCount = vertices.count / 8
    
    // Compute bounding box
    var minX : Float = 0.0
    var maxX : Float = 0.0
    var minY : Float = 0.0
    var maxY : Float = 0.0
    for (i, v) in vertices.enumerated() {
        if i % 8 == 0 {
            if v < minX {
                minX = v
            }
            else if v > maxX {
                maxX = v
            }
        }
        else if i % 8 == 1 {
            if v < minY {
                minY = v
            }
            else if v > maxY {
                maxY = v
            }
        }
    }
    
    renderable.boundingBox = Rect(x: minX, y: minY, w: maxX - minX, h: maxY - minY)
    
    let boundingBoxVerts : [Float] = [
        minX, minY, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
        minX, maxY, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
        maxX, maxY, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
        maxX, minY, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
        minX, minY, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    ]
    renderable.boundingBoxBuffer = gameMemory.platformCreateVertexBuffer!(boundingBoxVerts)
    
    return renderable
}

/****************************************
 * Entity Base
 ****************************************/

protocol Entity {
    var entity : EntityBaseRef { get set }
    static var renderableId : RenderableId { get } // Generated by build script for all renderables
    
    // Entity Base Properties
    var poolIndex : Int { get set }
    var renderableId : RenderableId { get }
    
    var p  : Vec2 { get set }
    var dP : Vec2 { get set }
    var rot  : Float { get set }
    var dRot : Float { get set }
    var scale : Float { get set }
}

extension Entity {
    var poolIndex : Int { get { return entity.poolIndex } set(val) {entity.poolIndex = val} }
    var renderableId : RenderableId { get { return entity.renderableId } }
    
    var p  : Vec2 { get { return entity.p } set(val) {entity.p = val} }
    var dP : Vec2 { get { return entity.dP } set(val) {entity.dP = val} }
    
    var rot  : Float { get { return entity.rot } set(val) {entity.rot = val} }
    var dRot : Float { get { return entity.dRot } set(val) {entity.dRot = val} }
    
    var scale : Float { get { return entity.scale } set(val) {entity.scale = val} }
}

/*= BEGIN_REFSTRUCT =*/
struct EntityBase {
    var poolIndex : Int /*= GETSET =*/
    var renderableId : RenderableId /*= GETSET =*/
    
    // Position and Velocity
    var p  : Vec2 /*= GETSET =*/
    var dP : Vec2 /*= GETSET =*/
    
    // Rotation and Angular Velocity
    var rot  : Float /*= GETSET =*/
    var dRot : Float /*= GETSET =*/
    
    var scale : Float /*= GETSET =*/
}
/*= END_REFSTRUCT =*/

/****************************************
 * Entity Functions
 ****************************************/

func createEntityBase<T : Entity>(_ entityRef: T, _ zone: MemoryZoneRef, _ gameState: GameStateRef) {
    var entity = entityRef
    let entityBasePtr = allocateTypeFromZone(zone, EntityBase.self)
    var entityBase = EntityBaseRef(ptr: entityBasePtr)
    entityBase.scale = 1.0
    entityBase.renderableId = T.renderableId
    let index = poolAdd(gameState.world.entities, entityBase)
    entityBase.poolIndex = index
    entity.entity = entityBase
}

func destroyEntity(_ gameState: GameStateRef, _ entity: Entity) {
    poolRemoveAtIndex(gameState.world.entities, entity.poolIndex)
}

func entityTransform(_ entity: EntityBaseRef) -> Transform {
    return translateTransform(entity.p.x, entity.p.y) * rotateTransform(entity.rot) * scaleTransform(entity.scale, entity.scale)
}

/****************************************
 * Ship
 ****************************************/


/*= BEGIN_REFSTRUCT =*/
struct Ship : Entity {
    var entity : EntityBaseRef /*= GETSET =*/
    var alive : Bool /*= GETSET =*/
}
/*= END_REFSTRUCT =*/

func createShip(_ gameMemory: GameMemory, _ zone: MemoryZoneRef, _ gameStateRef: GameStateRef) -> ShipRef {
    var gameState = gameStateRef
    
    let shipPtr = allocateTypeFromZone(zone, Ship.self)
    var ship = ShipRef(ptr: shipPtr)
    
    createEntityBase(ship, zone, gameState)
    
    ship.alive = true
    
    if gameState.renderables[Ship.renderableId] == nil {
        let verts : [Float] = [
            0.0,  0.7, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0,
            0.5, -0.7, 0.0, 1.0, 0.7, 1.0, 0.4, 1.0,
            -0.5, -0.7, 0.0, 1.0, 0.7, 1.0, 0.4, 1.0,
            ]
        let renderable = createRenderable(zone, gameState, gameMemory, verts)
        gameState.renderables[Ship.renderableId] = renderable
    }
    
    return ship
}


/****************************************
 * World
 ****************************************/

func createWorld(_ zone: MemoryZoneRef) -> WorldRef {
    let worldPtr = allocateTypeFromZone(zone, World.self)
    return WorldRef(ptr: worldPtr)
}


/****************************************
 * Asteroid
 ****************************************/

/*= BEGIN_REFSTRUCT =*/
struct Asteroid : Entity {
    var entity : EntityBaseRef /*= GETSET =*/
    
    enum AsteroidSize {
        case small
        case medium
        case large
    }
    
    var size : Asteroid.AsteroidSize /*= GETSET =*/
}
/*= END_REFSTRUCT =*/

func createAsteroid(_ gameMemory: GameMemory, _ zone: MemoryZoneRef, _ gameStateRef: GameStateRef, _ size: Asteroid.AsteroidSize) -> AsteroidRef {
    var gameState = gameStateRef
    
    let asteroidPtr = allocateTypeFromZone(zone, Asteroid.self)
    var asteroid = AsteroidRef(ptr: asteroidPtr)
    
    createEntityBase(asteroid, zone, gameState)
    
    asteroid.size = size
    asteroid.entity.scale = scaleForAsteroidSize(size)
    
    
    if gameState.renderables[Asteroid.renderableId] == nil {
        let verts : [Float] = [
            0.0,  0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            1.0,  0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            cos((FLOAT_TWO_PI) / 6.0), sin((FLOAT_TWO_PI) / 6.0), 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            
            0.0,  0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            cos((FLOAT_TWO_PI) / 6.0), sin((FLOAT_TWO_PI) / 6.0), 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            cos(2.0 * (FLOAT_TWO_PI) / 6.0), sin(2.0 * (FLOAT_TWO_PI) / 6.0), 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            
            0.0,  0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            cos(2.0 * (FLOAT_TWO_PI) / 6.0), sin(2.0 * (FLOAT_TWO_PI) / 6.0), 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            -1.0,  0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            
            0.0,  0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            -1.0,  0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            cos(4.0 * (FLOAT_TWO_PI) / 6.0), sin(4.0 * (FLOAT_TWO_PI) / 6.0), 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            
            0.0,  0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            cos(4.0 * (FLOAT_TWO_PI) / 6.0), sin(4.0 * (FLOAT_TWO_PI) / 6.0), 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            cos(5.0 * (FLOAT_TWO_PI) / 6.0), sin(5.0 * (FLOAT_TWO_PI) / 6.0), 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            
            0.0,  0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            cos(5.0 * (FLOAT_TWO_PI) / 6.0), sin(5.0 * (FLOAT_TWO_PI) / 6.0), 0.0, 1.0, 0.0, 0.0, 1.0, 1.0,
            1.0,  0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0
        ]
        let renderable = createRenderable(zone, gameState, gameMemory, verts)
        gameState.renderables[Asteroid.renderableId] = renderable
    }
    
    return asteroid
}

func scaleForAsteroidSize(_ size: Asteroid.AsteroidSize) -> Float {
    switch size {
    case .large:
        return 2.0
    case .medium:
        return 1.5
    case .small:
        return 1.0
    }
}

func randomizeAsteroidLocationInWorld(_ asteroidRef: AsteroidRef, _ world: WorldRef) {
    var asteroid = asteroidRef
    
    var location = Vec2()
    repeat {
        location.x = randomInRange(-world.size.w / 2.0, world.size.w / 2.0)
        location.y = randomInRange(-world.size.w / 2.0, world.size.w / 2.0)
    } while distance(location, world.ship.p) < (scaleForAsteroidSize(.large) * 2.0) // Prevent an asteroid from spawning right on top of the ship
    asteroid.p = location
}

func randomizeAsteroidRotationAndVelocity(_ asteroidRef: AsteroidRef) {
    var asteroid = asteroidRef
    asteroid.rot = randomInRange(-FLOAT_PI, FLOAT_PI)
    asteroid.dRot = randomInRange(FLOAT_TWO_PI / 900.0, FLOAT_TWO_PI / 700.0)
    var velocityScale : Float = 0.02
    if asteroid.size == .medium {
        velocityScale = 0.04
    }
    else if asteroid.size == .small {
        velocityScale = 0.06
    }
    asteroid.dP.x = randomInRange(-velocityScale, velocityScale)
    asteroid.dP.y = randomInRange(-velocityScale, velocityScale)
}


/****************************************
 * Laser
 ****************************************/

/*= BEGIN_REFSTRUCT =*/
struct Laser : Entity {
    var entity : EntityBaseRef /*= GETSET =*/
    
    var timeAlive : Float /*= GETSET =*/
    var lifetime : Float /*= GETSET =*/
    var alive : Bool /*= GETSET =*/
}
/*= END_REFSTRUCT =*/

func createLaser(_ gameMemory: GameMemory, _ zone: MemoryZoneRef, _ gameStateRef: GameStateRef, _ ship: ShipRef) -> LaserRef {
    var gameState = gameStateRef
    let laserPtr = allocateTypeFromZone(zone, Laser.self)
    var laser = LaserRef(ptr: laserPtr)
    
    createEntityBase(laser, zone, gameState)
    
    laser.p = ship.p

    laser.dP.x = sin(ship.rot) * 0.2
    laser.dP.y = cos(ship.rot) * 0.2
    
    laser.timeAlive = 0.0
    laser.lifetime = 1.0
    laser.alive = true
    
    if gameState.renderables[Laser.renderableId] == nil {
        let verts : [Float] = [
            1.0,  1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
            -1.0,  1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
            -1.0, -1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
            
            1.0,  1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
            -1.0, -1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
            1.0, -1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0
        ]
        let renderable = createRenderable(zone, gameState, gameMemory, verts)
        gameState.renderables[Laser.renderableId] = renderable
    }
    
    return laser
}



func rotateEntity<T : Entity>(_ entity: T, _ radians: Float) {
    var ref = entity
    ref.rot += radians
    ref.rot = normalizeToRange(entity.rot, Float(-M_PI), Float(M_PI))
}
